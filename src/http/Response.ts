/**
 * Copyright 2022 Dhiego Cassiano Foga√ßa Barbosa
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { type ReadStream, createReadStream, statSync } from "node:fs";
import type { OutgoingHttpHeader, OutgoingHttpHeaders } from "node:http";
import { Readable, type Transform } from "node:stream";
import { contentType } from "mime-types";

import { EStatusCode } from "./EStatusCode.js";
import type Request from "./Request.js";
import HTTPError from "../errors/HTTPError.js";
import { type Channel, rss } from "../util/rss.js";
import { serializeXML, serializeXMLGenerator, type XMLNode } from "../util/xml.js";
import { generateRandomString } from "../util/strings.js";

/**
 * Problem Details for HTTP APIs.
 */
export type ProblemDetails = {
    /** A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation). */
    title: string;
    /** A human-readable explanation specific to this occurrence of the problem. */
    detail: string;
    /** The HTTP status code generated by the origin server for this occurrence of the problem. */
    status?: number;
    /** A URI reference that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be "about:blank". */
    type?: string;
    /** A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced. */
    instance?: string;
    /** Problem type definitions MAY extend the problem details object with additional members. */
    [key: string]: unknown;
};

type Bufferable = Buffer | string | (Buffer | string)[];
type Streamable = Readable | Iterable<Bufferable> | AsyncIterable<Bufferable>;

type CookieOptions = {
    /** Defines the host to which the cookie will be sent. */
    domain?: string;
    /** Indicates the path that must exist in the requested URL for the browser to send the Cookie header. */
    path?: string;
    /** Indicates the maximum lifetime of the cookie as an HTTP-date timestamp. */
    expires?: Date;
    /** Indicates the number of seconds until the cookie expires. A zero or negative number will expire the cookie immediately. */
    maxAge?: number;
    /** Indicates that the cookie is sent to the server only when a request is made with the https: scheme (except on localhost), and therefore, is more resistant to man-in-the-middle attacks. */
    secure?: boolean;
    /** Forbids JavaScript from accessing the cookie, for example, through the `Document.cookie` property. */
    httpOnly?: boolean;
    /** Controls whether or not a cookie is sent with cross-site requests, providing some protection against cross-site request forgery attacks (CSRF). */
    sameSite?: 'strict' | 'lax' | 'none';
    /** Indicates that the cookie should be stored using partitioned storage. */
    partitioned?: boolean;
};

type CacheControlExpiration = {
    /** The max-age=N response directive indicates that the response remains fresh until N seconds after the response is generated. */
    maxAge?: number;
    /** The s-maxage response directive indicates how long the response remains fresh in a shared cache. The s-maxage directive is ignored by private caches, and overrides the value specified by the max-age directive or the Expires header for shared caches, if they are present.  */
    sharedMaxAge?: number;
    /** The max-stale=N request directive indicates that the client allows a stored response that is stale within N seconds. If no N value is specified, the client will accept a stale response of any age. */
    maxStale?: number;
    /** The min-fresh=N request directive indicates that the client allows a stored response that is fresh for at least N seconds. */
    minFresh?: number;
    /** The stale-while-revalidate response directive indicates that the cache could reuse a stale response while it revalidates it to a cache. */
    staleWhileRevalidate?: number;
    /** he stale-if-error response directive indicates that the cache can reuse a stale response when an upstream server generates an error, or when the error is generated locally. */
    staleIfError?: number;
};

type CacheControlRevalidation = {
    /** The must-revalidate response directive indicates that the response can be stored in caches and can be reused while fresh. If the response becomes stale, it must be validated with the origin server before reuse. */
    mustRevalidate?: boolean;
    /** The proxy-revalidate response directive is the equivalent of must-revalidate, but specifically for shared caches only. */
    proxyRevalidate?: boolean;
    /** The immutable response directive indicates that the response will not be updated while it's fresh. */
    immutable?: boolean;
};

type CacheControlOptions = {
    /** The no-store response directive indicates that any caches of any kind (private or shared) should not store this response. */
    noStore?: boolean;
    /** no-transform indicates that any intermediary (regardless of whether it implements a cache) shouldn't transform the response contents. */
    noTransform?: boolean;
};

/**
 * Representation of a HTTP Response.
 *
 * @template T The type of the data to be sent.
 */
export default class Response<T = any> {
    #headers = new Map<string, OutgoingHttpHeader>();
    #status: number = EStatusCode.OK;
    #body: Buffer[] = [];
    #stream?: Readable;
    #pipeStreams: Transform[] = [];
    #earlyHints: Map<string, string[]> = new Map();

    static #transformers: Map<string, (data: unknown, options?: unknown) => Bufferable> = new Map();
    static #streamTransformers: Map<string, (data: unknown, options?: unknown) => Streamable> = new Map();

    static {
        Response.installTransformer('application/json', (data: unknown): Bufferable => {
            return JSON.stringify(data);
        });

        Response.installStreamTransformer('application/json', (data: unknown, options: unknown): Streamable => {
            return Readable.from(JSON.stringify(data, null, options as number));
        });

        Response.installTransformer('application/json-bigint', (data: unknown, options: unknown): Bufferable => {
            return JSON.stringify(data, (_, v) => typeof v === 'bigint' ? v.toString() + 'n' : v, options as number);
        });

        Response.installStreamTransformer('application/json-bigint', (data: unknown): Streamable => {
            return Readable.from(JSON.stringify(data, (_, v) => typeof v === 'bigint' ? v.toString() + 'n' : v));
        });

        Response.installTransformer('application/xml', (data: unknown, options: unknown): Bufferable => {
            return serializeXML(data as XMLNode, options as number);
        });

        Response.installStreamTransformer('application/xml', (data: unknown, options: unknown): Streamable => {
            return Readable.from(serializeXMLGenerator(data as XMLNode, options as number));
        });
    }

    /**
     * Add a header to the response.
     *
     * @param key The header key.
     * @param value The header value.
     */
    withHeader<H extends keyof OutgoingHttpHeaders>(key: H, value: OutgoingHttpHeaders[H]): Response<T>;
    withHeader(key: string, value: OutgoingHttpHeader): Response<T> {
        // TODO: Add autocomplete for key.
        this.#headers.set(key as string, value!);

        return this;
    }

    /**
     * Add multiple headers to the response.
     *
     * @param headers The headers to be added.
     * @returns The response object.
     */
    withHeaders(headers: OutgoingHttpHeaders): Response<T> {
        for (const key in headers) {
            const value = headers[key]!;
            this.#headers.set(key, value);
        }

        return this;
    }

    /**
     * Add a cookie to the response. The Set-Cookie header will be set and automatically appended.
     *
     * @param key The cookie key.
     * @param value The cookie value.
     * @param options The cookie options.
     * @returns The response object.
     */
    withCookie(key: string, value: string, options?: CookieOptions): Response<T> {
        let cookie = `${key}=${value};`;

        if (options?.domain) {
            cookie += ` Domain=${options.domain};`;
        }

        if (options?.path) {
            cookie += ` Path=${options.path};`;
        }

        if (options?.expires) {
            cookie += ` Expires=${options.expires.toUTCString()};`;
        }

        if (options?.maxAge) {
            cookie += ` Max-Age=${options.maxAge};`;
        }

        if (options?.secure) {
            cookie += ' Secure;';
        }

        if (options?.httpOnly) {
            cookie += ' HttpOnly;';
        }

        if (options?.sameSite) {
            cookie += ` SameSite=${options.sameSite};`;
        }

        if (options?.partitioned) {
            cookie += ' Partitioned;';
        }

        if (this.#headers.has('Set-Cookie')) {
            const setCookie = this.#headers.get('Set-Cookie')!;
            if (Array.isArray(setCookie)) {
                setCookie.push(cookie);
            } else {
                this.#headers.set('Set-Cookie', [setCookie as string, cookie]);
            }
        } else {
            this.#headers.set('Set-Cookie', [cookie]);
        }

        return this;
    }

    /**
     * Add an early hint to the response. It uses the `res.writeEarlyHints` method.
     *
     * @param key The header key.
     * @param value The header value.
     * @returns The response object.
     */
    withEarlyHint(key: string, value: string): Response<T> {
        if (!this.#earlyHints.has(key)) {
            this.#earlyHints.set(key, []);
        }

        this.#earlyHints.get(key)!.push(value);

        return this;
    }

    /**
     * Add a Cache-Control header to the response.
     *
     * @param kind The kind of Cache-Control header. It can be `public`, `private`, `no-cache` or `only-if-cached`.
     * @param expiration The expiration options, such as `maxAge`.
     * @param revalidation The revalidation options, such as `mustRevalidate`.
     * @param options The additional options, such as `noStore`.
     *
     * @returns The response object.
     */
    withCacheControl(
        kind: 'public' | 'private' | 'no-cache' | 'only-if-cached',
        expiration?: CacheControlExpiration,
        revalidation?: CacheControlRevalidation,
        options?: CacheControlOptions
    ): Response<T> {
        let cacheControl = kind;

        if (expiration?.maxAge) {
            cacheControl += `, max-age=${expiration.maxAge}`;
        }

        if (expiration?.sharedMaxAge) {
            cacheControl += `, s-maxage=${expiration.sharedMaxAge}`;
        }

        if (expiration?.maxStale) {
            cacheControl += `, max-stale=${expiration.maxStale}`;
        }

        if (expiration?.minFresh) {
            cacheControl += `, min-fresh=${expiration.minFresh}`;
        }

        if (expiration?.staleWhileRevalidate) {
            cacheControl += `, stale-while-revalidate=${expiration.staleWhileRevalidate}`;
        }

        if (expiration?.staleIfError) {
            cacheControl += `, stale-if-error=${expiration.staleIfError}`;
        }

        if (revalidation?.mustRevalidate) {
            cacheControl += ', must-revalidate';
        }

        if (revalidation?.proxyRevalidate) {
            cacheControl += ', proxy-revalidate';
        }

        if (revalidation?.immutable) {
            cacheControl += ', immutable';
        }

        if (options?.noStore) {
            cacheControl += ', no-store';
        }

        if (options?.noTransform) {
            cacheControl += ', no-transform';
        }

        return this.withHeader('Cache-Control', cacheControl);
    }

    /**
     * Add an ETag header to the response.
     *
     * @param value The ETag value.
     * @returns The response object.
     */
    withETag(value: string): Response<T> {
        return this.withHeader('ETag', value);
    }

    /**
     * Add a Last-Modified header to the response.
     *
     * @param value The Last-Modified value.
     * @returns The response object.
     */
    withLastModified(value: Date): Response<T> {
        return this.withHeader('Last-Modified', value.toUTCString());
    }

    /**
     * Send pure data. Automatically converts strings to Buffers using UTF-8 encoding.
     *
     * @param data The data to be sent. If an array is passed, each item will be sent as a separate chunk.
     * @returns The response object.
     */
    send(data: Bufferable): Response<T> {
        if (Array.isArray(data)) {
            for (const chunk of data) {
                this.#body.push(typeof chunk === 'string' ? Buffer.from(chunk, 'utf8') : chunk);
            }
        } else {
            this.#body.push(typeof data === 'string' ? Buffer.from(data, 'utf8') : data);
        }

        return this;
    }

    /**
     * Send a stream. Streams have priority over other data.
     *
     * @param stream The stream to be sent.
     * @returns The response object.
     */
    stream(stream: Streamable): Response<T> {
        this.#stream = stream instanceof Readable ? stream : Readable.from(stream);

        return this;
    }

    /**
     * Send JSON data. The Content-Type header will be set to application/json and the data will automatically be converted to JSON string.
     *
     * @param data The data to be sent.
     * @param stream If the data should be streamed.
     * @param spaces The number of spaces to use for indentation.
     */
    json(data: T, stream: boolean = false, spaces?: number): Response<T> {
        this.withHeader('Content-Type', 'application/json');
        if (stream) {
            this.stream(Response.#streamTransformers.get('application/json')!(data, spaces));
        } else {
            this.send(Response.#transformers.get('application/json')!(data, spaces));
        }

        return this;
    }

    /**
     * Send JSON data with BigInt support. The Content-Type header will be set to application/json-bigint and the data will automatically be converted to JSON string.
     *
     * @param data The data to be sent.
     * @param stream If the data should be streamed.
     * @param spaces The number of spaces to use for indentation.
     */
    jsonBigint(data: T, stream: boolean = false, spaces?: number): Response<T> {
        this.withHeader('Content-Type', 'application/json-bigint');
        if (stream) {
            this.stream(Response.#streamTransformers.get('application/json-bigint')!(data, spaces));
        } else {
            this.send(Response.#transformers.get('application/json-bigint')!(data, spaces));
        }

        return this;
    }

    /**
     * Send a Problem Details response.
     * @param title A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation).
     * @param detail A human-readable explanation specific to this occurrence of the problem.
     * @param status The HTTP status code generated by the origin server for this occurrence of the problem.
     * @param type A URI reference that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be "about:blank".
     * @param instance A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
     * @param extensions Problem type definitions MAY extend the problem details object with additional members.
     * @returns The response object.
     */
    problem(title: string, detail: string, status?: number, type?: string | null, instance?: string, extensions?: Record<string, unknown>): Response<ProblemDetails> {
        (<Response<ProblemDetails>> this).json({
            title,
            detail,
            status,
            type: type ?? 'about:blank',
            instance,
            ...extensions
        }).withHeader('Content-Type', 'application/problem+json');

        if (status) {
            this.withStatus(status);
        }

        return (<Response<ProblemDetails>> this);
    }

    /**
     * Send data based on the Accept header of the request. The Content-Type header will be set accordingly.
     *
     * @param data The data to be sent.
     * @param req The request object.
     * @param order The order of priority for the Accept header. If not set, the order will be based on the request's Accept header.
     * @returns The response object.
     */
    auto(data: T, req: Request, order?: string[]): Response<T> {
        const priority = order ?? req.acceptPriority;

        for (const type of priority) {
            if (type.endsWith('/*')) {
                const baseType = type.slice(0, -2);
                const transformers = Array.from(Response.#transformers.keys()).filter(t => t.startsWith(baseType));

                if (transformers.length > 0) {
                    this.withHeader('Content-Type', transformers[0])
                        .send(Response.#transformers.get(transformers[0])!(data));

                    return this;
                }
            } else if (Response.#transformers.has(type)) {
                this.withHeader('Content-Type', type)
                    .send(Response.#transformers.get(type)!(data));

                return this;
            }
        }

        if (priority.includes('*/*')) {
            const transformer = 'application/json';

            this.withHeader('Content-Type', transformer)
                .send(Response.#transformers.get(transformer)!(data));

            return this;
        }

        throw new HTTPError('This server cannot process the requested Content-Type.', EStatusCode.NOT_ACCEPTABLE);
    }

    /**
     * Send a HTML response. The Content-Type header will be set to text/html.
     *
     * @param data The HTML data to be sent.
     * @returns The response object.
     */
    html(data: string): Response<T> {
        return this.withHeader('Content-Type', 'text/html')
            .send(data);
    }

    /**
     * Send a XML response. The Content-Type header will be set to application/xml.
     *
     * @param data The XML data to be sent.
     * @param stream If the data should be streamed.
     * @param spaces The number of spaces to use for indentation.
     * @returns The response object.
     */
    xml(data: XMLNode, stream: boolean = false, spaces?: number): Response<T> {
        this.withHeader('Content-Type', 'application/xml');
        if (stream) {
            this.stream(Response.#streamTransformers.get('application/xml')!(data, spaces));
        } else {
            this.send(Response.#transformers.get('application/xml')!(data, spaces));
        }

        return this;
    }

    /**
     * Send a RSS feed. The Content-Type header will be set to application/rss+xml.
     *
     * @param channel The RSS channel.
     * @returns The response object.
     */
    rss(channel: Channel): Response<T> {
        return this.xml(rss(channel))
            .withHeader('Content-Type', 'application/rss+xml');
    }

    /**
     * Send a File. The Content-Type header will be set based on the filename. The file will be streamed.
     *
     * @param filename The path to the file to be sent.
     * @param req The request object. If the request has a Range header, the file will be sent partially.
     * @returns The response object.
     */
    file(filename: string, req?: Request): Response<T> {
        function parseRange(range: string): [number, number] {
            if (/^\d+-\d+$/.test(range)) {
                const [start, end] = range.split('-').map(Number);
                return [start, end];
            }

            if (/^\d+-$/.test(range)) {
                const start = Number(range.substring(0, range.length - 1));
                return [start, Infinity];
            }

            if (/^-\d+$/.test(range)) {
                const end = Number(range.substring(1));
                return [Infinity, end];
            }

            throw new HTTPError('Invalid range header.', EStatusCode.BAD_REQUEST);
        }

        function fixRange(ranges: [number, number], filesize: number): [number, number] {
            const [start, end] = ranges;

            if (start === Infinity) {
                return [Math.max(0, filesize - end - 1), filesize - 1];
            }

            if (end === Infinity || end >= filesize) {
                return [start, filesize - 1];
            }

            return [start, end];
        }

        const filesize = statSync(filename).size;
        if (req?.headers.range) {
            if (!req.headers.range.startsWith('bytes=')) {
                throw new HTTPError('Invalid range header.', EStatusCode.BAD_REQUEST);
            }

            const ranges = req.headers.range.substring('bytes='.length).split(',').map(range => fixRange(parseRange(range.trim()), filesize));
            const streams: { start: number; end: number; stream: ReadStream; }[] = [];

            for (const [start, end] of ranges) {
                if (start >= filesize || end >= filesize) {
                    throw new HTTPError('Cannot read beyond the end of the file.', EStatusCode.RANGE_NOT_SATISFIABLE, {}, {
                        'Content-Range': `bytes */${filesize}`
                    });
                }

                if (start > end || start < 0 || end < 0) {
                    throw new HTTPError('Invalid range provided.', EStatusCode.RANGE_NOT_SATISFIABLE, {}, {
                        'Content-Range': `bytes */${filesize}`
                    });
                }

                const stream = createReadStream(filename, { start, end });

                streams.push({ start, end, stream });
            }

            if (streams.length > 1) {
                const boundary = 'boundary' + generateRandomString(16);

                return this.withHeader('Content-Type', 'multipart/byteranges; boundary=' + boundary)
                    .withStatus(EStatusCode.PARTIAL_CONTENT)
                    .withHeader('Accept-Ranges', 'bytes')
                    .stream(Readable.from(streams.flatMap(({ start, end, stream }) => {
                        return [
                            `--${streams.length > 1 ? boundary : ''}`,
                            `Content-Type: ${contentType(filename) || 'application/octet-stream'}`,
                            `Content-Range: bytes ${start}-${end}/${filesize}`,
                            '',
                            stream
                        ];
                    })));
            }

            if (streams.length === 1) { // Check for 1 to ensure that the array is not empty.
                const [{ start, end, stream }] = streams;

                return this.withHeader('Content-Type', contentType(filename) || 'application/octet-stream')
                    .withStatus(EStatusCode.PARTIAL_CONTENT)
                    .withHeader('Content-Range', `bytes ${start}-${end}/${filesize}`)
                    .withHeader('Accept-Ranges', 'bytes')
                    .stream(stream);
            }
        }

        const res = this.withHeader('Content-Type', contentType(filename) || 'text/plain')
            .stream(createReadStream(filename));

        if (req) {
            res.withHeader('Accept-Ranges', 'bytes');
        }

        return res;
    }

    /**
     * Set the status code of the response.
     *
     * @param code The status code.
     * @returns The response object.
     */
    withStatus(code: number): Response<T> {
        this.#status = code;

        return this;
    }

    /**
     * Empty the response body.
     *
     * @returns The response object.
     */
    empty(): Response<T> {
        this.#body = [];

        return this;
    }

    /**
     * Pipe the response to a Transform stream.
     *
     * @param stream The stream to be piped.
     * @returns The response object.
     */
    pipe(stream: Transform): Response<T> {
        this.#pipeStreams.push(stream);

        return this;
    }

    get headers() {
        return this.#headers;
    }

    get status() {
        return this.#status;
    }

    /**
     * Get the body of the response as a Readable stream.
     */
    get body(): Readable {
        let stream = this.#stream ?? Readable.from(this.#body);

        for (const transform of this.#pipeStreams) {
            stream = stream.pipe(transform);
        }

        return stream;
    }

    /**
     * Get the length of the response body. If the response is a stream, -1 will be returned.
     */
    get length() {
        if (this.isStream) {
            return -1;
        }

        return this.#body.reduce((acc, chunk) => acc + chunk.length, 0);
    }

    /**
     * Check if the response is a stream.
     */
    get isStream() {
        return this.#stream !== undefined || this.#pipeStreams.length > 0;
    }

    /**
     * Get the early hints of the response.
     */
    get earlyHints(): Record<string, string | string[]> | null {
        if (this.#earlyHints.size === 0) {
            return null;
        }

        const hints: Record<string, string | string[]> = {};

        for (const [key, value] of this.#earlyHints) {
            hints[key] = value;
        }

        return hints;
    }

    /**
     * Send pure data. Automatically converts strings to Buffers using UTF-8 encoding.
     *
     * @param data The data to be sent. If an array is passed, each item will be sent as a separate chunk.
     * @returns The response object.
     */
    static send(data: Bufferable): Response {
        return new Response()
            .send(data);
    }

    /**
     * Send a stream. Streams have priority over other data.
     *
     * @param stream The stream to be sent.
     * @returns The response object.
     */
    static stream(stream: Streamable): Response {
        return new Response()
            .stream(stream);
    }

    /**
     * Send JSON data. The Content-Type header will be set to application/json and the data will automatically be converted to JSON string.
     *
     * @param data The data to be sent.
     * @param stream If the data should be streamed.
     * @param spaces The number of spaces to use for indentation.
     */
    static json<T = any>(data: T, stream: boolean = false, spaces?: number): Response<T> {
        return new Response<T>()
            .json(data, stream, spaces);
    }

    /**
     * Send JSON data with BigInt support. The Content-Type header will be set to application/json-bigint and the data will automatically be converted to JSON string.
     *
     * @param data The data to be sent.
     * @param stream If the data should be streamed.
     * @param spaces The number of spaces to use for indentation.
     */
    static jsonBigint<T = any>(data: T, stream: boolean = false, spaces?: number): Response<T> {
        return new Response<T>()
            .jsonBigint(data, stream, spaces);
    }

    /**
     * Send a Problem Details response.
     * @param title A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation).
     * @param detail A human-readable explanation specific to this occurrence of the problem.
     * @param status The HTTP status code generated by the origin server for this occurrence of the problem.
     * @param type A URI reference that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be "about:blank".
     * @param instance A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
     * @param extensions Problem type definitions MAY extend the problem details object with additional members.
     * @returns The response object.
     */
    static problem(title: string, detail: string, status?: number, type?: string | null, instance?: string, extensions?: Record<string, unknown>): Response<ProblemDetails> {
        return new Response<ProblemDetails>()
            .problem(title, detail, status, type, instance, extensions);
    }

    /**
     * Send data based on the Accept header of the request. The Content-Type header will be set accordingly.
     *
     * @param data The data to be sent.
     * @param req The request object.
     * @param order The order of priority for the Accept header. If not set, the order will be based on the request's Accept header.
     * @returns The response object.
     */
    static auto<T = any>(data: T, req: Request, order?: string[]): Response<T> {
        return new Response<T>()
            .auto(data, req, order);
    }

    /**
     * Send a HTML response. The Content-Type header will be set to text/html.
     *
     * @param data The HTML data to be sent.
     * @returns The response object.
     */
    static html(data: string): Response {
        return new Response()
            .html(data);
    }

    /**
     * Send a XML response. The Content-Type header will be set to application/xml.
     *
     * @param data The XML data to be sent.
     * @param stream If the data should be streamed.
     * @param spaces The number of spaces to use for indentation.
     * @returns The response object.
     */
    static xml(data: XMLNode, stream: boolean = false, spaces?: number): Response {
        return new Response()
            .xml(data, stream, spaces);
    }

    /**
     * Send a RSS feed. The Content-Type header will be set to application/rss+xml.
     *
     * @param channel The RSS channel.
     * @returns The response object.
     */
    static rss(channel: Channel): Response {
        return new Response()
            .rss(channel);
    }

    /**
     * Send a File. The Content-Type header will be set based on the filename. The file will be streamed.
     *
     * @param filename The path to the file to be sent.
     * @param req The request object. If the request has a Range header, the file will be sent partially.
     * @returns The response object.
     */
    static file(filename: string, req?: Request): Response {
        return new Response()
            .file(filename, req);
    }

    /**
     * Set the status code of the response.
     *
     * @param code The status code.
     * @returns The response object.
     */
    static status(code: number): Response {
        return new Response()
            .withStatus(code);
    }

    /**
     * Send a empty (204) response.
     */
    static empty(): Response {
        return new Response()
            .withStatus(EStatusCode.NO_CONTENT);
    }

    /**
     * Send a redirect (302) response.
     */
    static redirect(to: string): Response {
        return new Response()
            .withStatus(EStatusCode.FOUND)
            .withHeader('Location', to);
    }

    /**
     * Send a permanent redirect (301) response.
     */
    static redirectPermanent(to: string): Response {
        return new Response()
            .withStatus(EStatusCode.MOVED_PERMANENTLY)
            .withHeader('Location', to);
    }

    /**
     * Send an early hint (103) response.
     */
    static earlyHint(key: string, value: string): Response {
        return new Response()
            .withEarlyHint(key, value);
    }

    static installTransformer(type: string, transformer: (data: unknown, options?: unknown) => Bufferable) {
        Response.#transformers.set(type, transformer);
    }

    static installStreamTransformer(type: string, transformer: (data: unknown, options?: unknown) => Streamable) {
        Response.#streamTransformers.set(type, transformer);
    }
}
